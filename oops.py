# -*- coding: utf-8 -*-
"""OOPS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rtYMbhw8kK3cIBzuFrWQU65L3p8kuRB_

**Object-Oriented Programming (OOP)**

The concept of OOP in Python focuses on creating reusable code. This concept is also known as DRY (Don't Repeat Yourself).

**Key Points to Remember:**

1. The programming gets easy and efficient.
2. The class is sharable, so codes can be reused.
3. The productivity of programmars increases
4. Data is safe and secure with data abstraction.
5. OOP makes it easy to maintain and modify existing code as new objects can be created with small differences to existing ones.

Python is a **multi-paradigm** programming language. Meaning, it supports different programming approach.

One of the popular approach to solve a programming problem is by creating objects. This is known as Object-Oriented Programming (OOP).

**An object has two characteristics**:

1. attributes

2. behavior

Let's take an example:

Parrot is an object,

name, age, color are **attributes**

singing, dancing are **behavior**

Object Oriented Programming (OOP) is a programming style which is associated with the concepts like class, object, Inheritance, Encapsulation, Abstraction, Polymorphism.

**Class**

**A class is a blueprint for the object.**

*a. Defining a Python Class*

**To define a class in python programming, we use the ‘class’ keyword.**

This is like we use ‘def’ to define a function in python.

***And like a function, a Python3 class may have a docstring as well.***


We can do this to write a couple of lines explaining what the class does.

To focus on the syntax here, we will pass in a ‘pass’ statement in its body for now.

We can think of class as an sketch of a parrot with labels. It contains all the details about the name, colors, size etc. Based on these descriptions, we can study about the parrot. Here, parrot is an object.

The example for class of parrot can be :

### Defining classes and objects
A class is a technique to group functions and data members and put them in a container so that they can be accessed later by using dot (.) operator. 

Objects are the basic runtime entities of object-oriented programming. It defines the instance of a class. Objects get their variables and functions from classes and the class we will be creating are the templates made to create the object.

* class: Classes are a user-defined data type that is used to encapsulate data and associated functions together. It also helps in binding data together into a single unit.
* Data Member: A variable or memory location name that holds value to does a specific task within a program.
* Member Function: They are the functions; usually a block of a code snippet that is written to re-use it.
* Instance variable: A variable that is defined inside a method of a class.
* Function Overloading: This technique is used to assign multiple tasks to a single function & the tasks are performed based on the number of argument or the type of argument the function has.
* Operator Overloading: It is the technique of assigning multiple function/tasks to a particular operator.
* Inheritance: It is the process of acquiring the properties of one class to another, i.e., one class can acquire the properties of another.
* Instantiation: It is the technique of creating an instance of a class.
"""

class Parrot:
            """
            This Python3 class creates instances of fruits
            """
            pass

Parrot.__doc__
#Parrot

"""Here, we use class keyword to define an empty class Parrot. From class, we construct instances. An instance is a specific object created from a particular class.

**Object**

Everything in Python is an object. Objects are basic building blocks of a Python OOP program. 

An object (instance) is an instantiation of a class. When class is defined, only the description for the object is defined. Therefore, no memory or storage is allocated.
"""

print(type(1))
print(type(""))
print(type([]))
print(type({}))
print(type(()))
print(type(object))
print(type(sys))

"""In this example we show that all these entities are in fact objects. The type() function returns the type of the object specified.

Integers, strings, lists, dictionaries, tuples, functions, and modules are Python objects.
"""

#The example for object of parrot class can be:

obj = Parrot()

"""Here, obj is object of class Parrot.

**An instance (attribute) is a characteristic of an object.**

For example, we can create a class called parrot. An instance (attribute) of a parrot may be its species or its name and age.

Let's get a better understanding of instance through an example.

Instance

The syntax for creating an instance is:

>self.instance = something

Suppose we have details of parrot. Now, we are going to show how to build the class and objects of parrot.
"""

#Creating Class and Object in Python

class Parrot:
    # instance attribute
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(name)
# instantiate the Parrot class
parrot1 = Parrot("Blu", 10)
parrot2 = Parrot("Woo", 15)

parrot1.color="pink"

print(parrot1.color)

#blu.color
parrot3=parrot1  #assigning object in different variable
parrot3.color

"""Then, we create instances of the Parrot class. Here, blu and woo are references (value) to our new objects.

There is a special method called:
"""

__init__()

"""This method is used to initialize the attributes of an object.

The `__init__` method run as soon as an object of a class is instantiated. The method is useful to do any initialization you want to do with your object.

In above example,, we define the `__init__` method as taking a parameter name and age (along with the usual self).

**self**

1. Class methods must have an extra first parameter in method definition. The self parameter is a reference to the current instance of the class, and is used to access variables that belongs to the class.

2. We do not give a value for this parameter when we call the method, Python provides it
3. If we have a method which takes no arguments, then we still have to have one argument – the self. See fun() in below simple example.
4. This is similar to this pointer in C++ and this reference in Java.
"""

# A simple example class 
class Test: 
      
    # A sample method  
    def fun(self): 
        print("Hello") 
        def fun1():
          print("hi")
        fun1()

  
# Driver code 
obj = Test() 
obj.fun()

"""**Methods**

Methods are functions defined inside the body of a class. They are used to define the behaviors of an object.
"""

#Creating Methods in Python

class Parrot:
    # instance attributes
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # instance method
    def sing(self, song):
        return "{} sings {}".format(self.name, song)

    def dance(self):
        return "{} is now dancing".format(self.name)

# instantiate the object
blu = Parrot("Blu", 10)

# call our instance methods
print(blu.sing("'Happy'"))
print(blu.dance())

"""In the above program, we define two methods i.e sing() and dance(). These are called instance method because they are called on an instance object i.e blu.

# Bounded and Unbounded Call

Calling of function using object is bounded call

calling of function using class name is unbounded call
className.functionName(object)
"""

class B:
  def first(self,a):
    print(a)
  def second():
    print("second Method")
ob=B()

#print(ob.y1)
B.second() #unbounded call
B.first(ob,2) #unbounded Call

"""**Inheritance**

A process of using details from a new class without modifying existing class.

Inheritance is a way of creating new class for using details of existing class without modifying it. The newly formed class is a derived class (or child class). Similarly, the existing class is a base class (or parent class).
"""

#Use of Inheritance in Python
# parent class
class Bird:
    def __init__(self):
        print("Bird is ready")

    def whoisThis(self):
        print("Bird")

    def swim(self):
        print("Swim faster")

# child class
class Penguin(Bird):

    def __init__(self):
        # call super() function
        super().__init__()
        print("Penguin is ready")

    def whoisThis(self):
        print("Penguin")

    def run(self):
        print("Run faster")

peggy = Penguin()
peggy.whoisThis()
peggy.swim()
peggy.run()

"""In the above program, we created two classes i.e. Bird (parent class) and Penguin (child class). The child class inherits the functions of parent class. We can see this from swim() method. Again, the child class modified the behavior of parent class. We can see this from whoisThis() method. Furthermore, we extend the functions of parent class, by creating a new run() method.

Additionally, we use **super()** function before `__init__()` method. This is because we want to pull the content of `__init__()` method from the parent class into the child class.
"""

class Square: 
     def __init__(self, side): 
       print("1")
       self.side = side 
     def area(self): 
         return self.side * self.side 
class Cube(Square):
     def __init__(self,a):
       super().__init__(a)
       print("2")
     def area(self): 
         print(super().area() * 6)
     def volume(self): 
         return super().area() * self.side()

c=Cube(3)
c.area()

"""**Python Multiple Inheritance**

Like C++, a class can be derived from more than one base classes in Python. This is called multiple inheritance.

In multiple inheritance, the features of all the base classes are inherited into the derived class. The syntax for multiple inheritance is similar to single inheritance.
"""

#Example

class Base1:
    pass
class Base2:
    pass
class MultiDerived(Base1, Base2):
    pass

"""Here, MultiDerived is derived from classes Base1 and Base2.

<p><img src="https://cdn.programiz.com/sites/tutorial2program/files/MultipleInheritance.jpg" alt="Multiple Inheritance in Python" /></p>

# **Day 2**

**Attribute Magic Methods	Description**:

__getattr__(self, name): Is called when the accessing attribute of a class that does not exist.

__setattr__(self, name, value):	Is called when assigning a value to the attribute of a class.

__delattr__(self, name):	Is called when deleting an attribute of a class.

__str__(self):	To get called by built-int str() method to return a string representation of a type.

Initialization and construction magic function:

__new__(cls, other):	To get called in an object's instantiation.

__init__(self, other):	To get called by the __new__ method.

__del__(self): Destructor method.
"""

class employee:
  def __new__(cls):
    print ("__new__ magic method is called")
    inst = object.__new__(cls)
    return inst
  def __init__(self):
    print ("__init__ magic method is called")
    self.name='Satya'

employee()

"""Let’s try an example in which `__new__` method returns an instance of a different class."""

# Python program to 
# demonstrate __new__ method 

# class whose object is returned 
class A: 
	def __str__(self): 
		return "Class A"
		
# class returning object of different class 
class B: 
	def __new__(cls): 
		return A()
		
	def __init__(self): 
		print("Inside init") 
print(B()) 

#inst = object.__new__(cls)

class A: 
	def __str__(self): 
		return "Class A"
		
a=A()
print(a.__str__())
print(A())

"""**Encapsulation**

Hiding the private details of a class from other objects.

Using OOP in Python, we can restrict access to methods and variables. This prevent data from direct modification which is called encapsulation. In Python, we denote private attribute using underscore as prefix i.e double “ __“.

**Access Modifier: Private**

These members are only accessible from within the class. No outside Access is allowed.
"""

class A:
    def __init__(self):
        self.__var = 123    #Private
        self._var2=1234     
    def printVar(self):
        print (self.__var)

ob=A()
#ob.__var    #can not access the private variable
ob._var2     # normal variable
ob.printVar()

"""Python performs name mangling of private variables. Every member with double underscore will be changed to `object._class__variable` 

If so required, it can still be accessed from outside the class, but the practice should be refrained.
"""

ob._A__var

ob.__var=10    #value will not be change directly
print(ob._A__var)

# protected
class Cup:
    def __init__(self):
        self.color = None
        self._content = None # protected variable

    def fill(self, beverage):
        self._content = beverage
        print(self._content)

    def empty(self):
        self._content = None
cup = Cup()
cup._content = "tea"
print(cup._content)
cup.fill("NOOO")
cup.empty()
print(cup._content)

"""**Getter and Setter Method**

We use getters & setters to add validation logic around getting and setting a value.
To avoid direct access of a class field i.e. **private variables cannot be accessed directly or modified by external user.**
"""

# Python program showing a use of get() and set() method in normal function 
class A: 
	def __init__(self, age = 0):
		self.__age = age
	
	# getter method 
	def get_age(self): 
		return self.__age 

	# setter method 
	def set_age(self, x): 
		self.__age = x 
raj = A() 

# setting the age using setter 
raj.set_age(21) 

# retrieving age using getter 
print(raj.get_age()) 
#print(raj.__age)

# Python program showing a use of property() function 
class ABES: 
	def __init__(self): 
		self.__age = 0
	
	# function to get value of _age 
	def get_age(self): 
		print("getter method called") 
		return self.__age 
	
	# function to set value of _age 
	def set_age(self, a): 
		print("setter method called") 
		self.__age = a 

	# function to delete _age attribute 
	def del_age(self): 
		del self.__age 
	
	var = property(get_age,set_age) 

mark = ABES() 

mark.var = 10
#print(mark.__age) 
mark.__age=9
print(mark.var)

#Data Encapsulation in Python
class Computer:
    def __init__(self):
        self.__maxprice = 900

    def sell(self):
        print("Selling Price: {}".format(self.__maxprice))

    def setMaxPrice(self, price):
        self.__maxprice = price

c = Computer()
c.sell()

# change the price
c.__maxprice = 1000
c.sell()

# using setter function
c.setMaxPrice(1000)
c.sell()

"""In the above program, we defined a class Computer. We use `__init__()` method to store the maximum selling price of computer. We tried to modify the price. However, we can’t change it because Python treats the __maxprice as private attributes. To change the value, we used a setter function i.e setMaxPrice() which takes price as parameter.

**Polymorphism**

A concept of using common operation in different ways for different data input.

Polymorphism is an ability (in OOP) to use common interface for multiple form (data types).

Suppose, we need to color a shape, there are multiple shape option (rectangle, square, circle). However we could use same method to color any shape. This concept is called Polymorphism
"""

#Using Polymorphism in Python

class Parrot:
    def fly(self):
        print("Parrot can fly")
    
    def swim(self):
        print("Parrot can't swim")

class Penguin:
    def fly(self):
        print("Penguin can't fly")
    
    def swim(self):
        print("Penguin can swim")

# common interface
def flying_test(bird):
    bird.fly()

#instantiate objects
blu = Parrot()
peggy = Penguin()

# passing the object
flying_test(blu)
flying_test(peggy)

"""In the above program, we defined two classes Parrot and Penguin. Each of them have common method fly() method. However, their functions are different. To allow polymorphism, we created common interface i.e flying_test() function that can take any object. Then, we passed the objects blu and peggy in the flying_test() function, it ran effectively.

#Abstract Class

An abstract class can be considered as a blueprint for other classes, allows you to create a set of methods that must be created within any child classes built from your abstract class. 

Abstract classes are classes that contain one or more abstract methods. 

An abstract method is a method that is declared, but contains no implementation.

Abstract classes may not be instantiated, and require subclasses to provide implementations for the abstract methods. 

Subclasses of an abstract class in Python are not required to implement abstract methods of the parent class.

Let's look at the following example:
"""

class AbstractClass:
    def do_something(self):
        pass
class B(AbstractClass):
    pass
a = AbstractClass()
b = B()

"""If we start this program, we see that this is not an abstract class, because:

-we can instantiate an instance from base class

-we are not required to implement do_something in the class defintition of B

Our example implemented a case of simple inheritance which has nothing to do with an abstract class. 

**In fact, Python on its own doesn't provide abstract classes.** 

Yet, Python comes with a module which provides the infrastructure for defining **Abstract Base Classes (ABCs)**. This module is called - for obvious reasons - abc.

The following Python code uses the abc module and defines an abstract base class:
"""

from abc import ABC, abstractmethod
class AbstractClassExample(ABC):
    def __init__(self, value):
        self.value = value
        super().__init__()
        
    @abstractmethod
    def do_something(self):
        pass

"""We will define now a subclass using the previously defined abstract class. 

You will notice that we haven't implemented the do_something method, even though we are required to implement it, because this method is decorated as an abstract method with the decorator "abstractmethod". 

We get an exception that DoAdd42 can't be instantiated:
"""

class DoAdd42(AbstractClassExample):
    pass

x = DoAdd42(4)

"""We will do it the correct way in the following example, in which we define two classes inheriting from our abstract class:"""

class DoAdd42(AbstractClassExample):
    def do_something(self):
        return self.value + 42
    
class DoMul42(AbstractClassExample):
    def do_something(self):
        return self.value * 42
    
x = DoAdd42(10)
y = DoMul42(10)

print(x.do_something())
print(y.do_something())

"""A class that is derived from an abstract class cannot be instantiated unless all of its abstract methods are overridden.


You may think that abstract methods can't be implemented in the abstract base class. This impression is wrong: An abstract method can have an implementation in the abstract class! 
Even if they are implemented, designers of subclasses will be forced to override the implementation.
"""

from abc import ABC, abstractmethod
 
class AbstractClassExample(ABC):
    @abstractmethod
    def do_something(self):
        print("Some implementation!")
        
class AnotherSubclass(AbstractClassExample):
    def do_something(self):
        super().do_something()
        print("The enrichment from AnotherSubclass")
        
x = AnotherSubclass()
x.do_something()

class stack:
  def __init__(self,n):
    self.stack_size=n
    self.List1=[]

  def is_Full(self,i):
    k=len(self.List1)
    if k<self.stack_size:
      self.push(i)
    else:
      print("stack is full")

  def push(self,name):
    self.List1.append(name)
    print(name)

n=int(input("size of stack"))
obj=stack(n)

l=["shirt1", "shirt2", "shirt3", "shirt4", "shirt5", "shirt6"]
for i in l:
  obj.is_Full(i)

size=5
n=[None]*size
n[0]=5
n

class A:
    def __init__(self,i):
        self.calcI(30)
        print("i from A is", self.i)

    def calcI(self, i):
        self.i = 2 * i;

class B(A):
    def __init__(self):
        super().__init__(self)
        
    def calcI(self, i):
        self.i = 3 * i;

b = B()

s="\t\t\n\nname\n\n\t\t"
print(s.strip())

class f:
  def __init__(self,a):
    self.j=a

class c(f):
  def __init__(self,a):
    self.k=a

ob=c(5)
print(ob.k)
print(ob.j) #can't access parent constructor